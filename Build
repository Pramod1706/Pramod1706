Thanks for the detailed follow-up â€” based on the Memory Analyzer Tool (MAT) heap dump and your system behavior (500 errors and OOM in backend APIs), let me now explain the full picture from scratch in simple terms and connect it with your production symptoms.


---

ğŸ§  What the MAT Heap Dump Tells Us (Freshly Explained)

âœ… Heap Size and Usage

Heap retained: 4.11 GB

One massive object: java.lang.Object[] holding 97.4% of the heap!

That object is tied to a thread running JDBC code in PostgreSQL driver (QueryExecutorImpl.processResults)


This means:

> ğŸ”¥ A single JDBC call has loaded almost all heap into memory via a very large result set.




---

ğŸ” Who Is Holding the Memory?

Thread Identified:

http-nio-8080-exec-8 (Tomcat worker thread handling an HTTP request)

Internally executing: org.postgresql.core.v3.QueryExecutorImpl.processResults()
This is the PostgreSQL JDBC driver processing a huge query response.



---

âš ï¸ Why This Happens (Root Cause)

This is not a normal JDBC call. You're likely:

Executing a large query (SELECT * FROM big_table or a massive join)

Not streaming results â€” so the whole result is loaded into Java heap

Possibly not closing JDBC resources properly


PostgreSQL JDBC loads everything unless you explicitly ask it to stream.


---

ğŸ” Why Youâ€™re Seeing 500 Errors Elsewhere

ğŸ”— Connection Blockage â†’ API Errors

If one request is:

Holding a 4+ GB result set

And the thread is stuck processing itâ€¦


Then:

That thread canâ€™t serve new requests

DB connections get exhausted (Hikari pool is blocked)

Other backend API requests fail with 500, even if theyâ€™re unrelated!


Itâ€™s a domino effect due to bad DB resource usage in one query.


---

ğŸ¯ Real Root Problems in Your Backend

Symptom	Actual Root Cause	Evidence

OOM (Out of Memory)	Huge JDBC result in heap	Object[] 97.4% of heap
500 errors	Thread + DB connection blocked	JDBC thread never finishes
Hikari pool stall	Connections not returned	Possible leak or long execution
Backend slowdown	GC and memory pressure	4+ GB used by one object



---

âœ… Step-by-Step Fix Strategy

ğŸ”§ 1. Fix Your JDBC Querying

Update your code like this (Java style):

Connection conn = dataSource.getConnection();
conn.setAutoCommit(false); // Required for PostgreSQL streaming

PreparedStatement stmt = conn.prepareStatement(
  "SELECT id, name FROM big_table", 
  ResultSet.TYPE_FORWARD_ONLY, 
  ResultSet.CONCUR_READ_ONLY
);
stmt.setFetchSize(50); // Stream data in chunks

ResultSet rs = stmt.executeQuery();
while (rs.next()) {
    // Process row
}
rs.close();
stmt.close();
conn.close();

> âš ï¸ Donâ€™t forget conn.setAutoCommit(false) â€” PostgreSQL needs this for streaming.




---

âš ï¸ 2. Enable Hikari Leak Detection

Add this in application.properties:

spring.datasource.hikari.leak-detection-threshold=2000

This will show logs if a connection is held longer than 2 seconds.


---

ğŸ” 3. Trace the Controller or Endpoint

Use thread dump or profiling to trace:

What controller/REST endpoint is triggering that huge query?

Does it use pagination or filtering?


Check if the offending call is serializing large datasets to JSON, which adds memory load.


---

ğŸ’¾ 4. Avoid Large JSON Responses

Returning entire tables as JSON will:

Bloat memory

Cause slow GC

Impact heap usage and CPU


Instead:

Paginate the results (limit/offset or cursor)

Stream in chunks using Spring WebFlux or StreamingResponseBody



---

ğŸš€ 5. Temporary Mitigation

Until you fix the code:

Increase heap from 6 GB â†’ 8 GB

Increase Hikari maximumPoolSize

Scale up backend pods (CPU & memory)

Add rate limit for that specific API



---

ğŸ§µ Your Backend Has This Lifecycle Problem:

JDBC Query â†’ Fetches Huge Result â†’ Retained in Heap â†’ GC Struggles
â†’ Tomcat Thread Held â†’ Connection Not Returned â†’ Hikari Starved
â†’ Other APIs Wait â†’ 500 Errors Everywhere


---

âœ… What You Should Do Today

1. Identify the API and SQL query tied to that http-nio-8080-exec-8 thread.


2. Apply streaming JDBC logic (with fetchSize and autoCommit(false)).


3. Enable leak detection and capture thread dump if needed.


4. Check GC logs â€” youâ€™ll likely see long GC pauses.


5. Avoid returning 1000s of records as JSON without pagination.




---

Let me know:

If you want me to review the actual controller or SQL query

If youâ€™re using Spring JDBC, Hibernate, JPA, or raw JDBC

And if this happens under normal load or only during JMeter testing


I'll tailor the exact fix/code.
